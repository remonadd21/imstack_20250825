# Java 복습문제

package com.company.java012;

////Q1. 상속도를 그리시오. 
/*
 * 
 * 		Object
 * 		  ↑
 * 		TestA4	(int a, ---------)
 * 
 * 		  ↑
 * 		TestB4	(int b, @toString)

 * */


class TestA4  extends Object{  
	int a=10;
	@Override public String toString() { return "TestA4 [a=" + a + "]"; }
}
class TestB4  extends TestA4{  
	int b=20;
	@Override public String toString() { return "TestB4 [b=" + b + "]"; }
}



public class PolyEx003 {

	public static void main(String[] args) {
	    TestA4  ta = new TestA4();
	    //Q2. TestA4  ta 사용할수 있는범위는?
	    // 부모인 A4가 자신 스스로의 heap area를 사용하고 있기 때문에 
	    // (int a , toString) 사용가능
	    
	    //Q3. new TestA4() 는  heap area 에서 호출되는 생성자의 순서와 객체가 만들어지는 순서는?
	    /*
	     * 생성자 : Test4() -> Object();
	     * 객체생성 : Object -> Test4();
	     * */
	    
	    TestB4  tb = new TestB4();  
	    
	    
	    //Q4. TestB4  tb 사용할수 있는범위는?
	    // TestB4가 자신 스스로의 heap area를 사용하고 있기 때문에 
	    // (int b, @toString) --- {a=10} 사용가능 
	    
	    //Q5. new TestB4() 는  heap area 에서 호출되는 생성자의 순서와 객체가 만들어지는 순서는?
	    // 생성자 : TestB4-> TestA4-> Object
	    // 객체생성 : Object -> TestA4 -> TestB4
	    ta = new TestB4();	    
	    
	    //Q6. ta가 사용할수 있는 보장하는 변수와 메서드는?
	
	    // 생성자는 아래서 위로 생성 123 객체는 456 위에서 아래로 생성
	    // 3			4
	    // 2			5
	    // 1			6
	    // 부모가 자녀를 담은 업 캐스팅
	    // 부모의 값을 가져오고, 자녀의 주소를 가져온다.
        // int a=10,  toString
	    
	    //Q7.ta = new TestB4(); 에서 new TestB4() 에서 사용할수 있는 범위는? 
	    // 자녀요소의 타입캐스팅이 부모 요소 앞에 적용되어 있기 때문에 
        // ta : {b=20, @toString} - {a=10}
	    // new TestB4 3000번지 실체 인스턴스화 {b=20, @toString} - {a=10}
        // ta(3000번지 ) = {b=20, @toString} - {a=10}
	  
      
        tb         = (TestB4) ta;   	   
	    //Q8. tb         = (TestB4) ta;   에서 tb가 사용할수 있는 범위는?
	    // 자녀에서 부모를 사용하도록 타입캐스팅이 되어 있음
	    // tb: (int b, @toString) --- {a=10} 사용가능 
        // ta  = 3000번지 {b=20 , @toString} - {a=10}
        // 타입캐스팅  = tb : b=20, @toString - a=10
	    
	    
	    //Q9. 컴파일러시  tb         = (TestB4) ta;  오류가 안나는 이유는?
        // 부모에서 자녀 생성자를 한번은 담았었기 때문에 오류가 나지 않음
        // ta가 사용할 수 있는 값은 a=10, toString 이었는데..
        // 자녀 생성자를 호출해서 b=20, @toString을 처리했기 때문에 오류나지 않음
	    
	    System.out.println(tb);  
	    //Q10. 출력내용과 그이유는? TestA4  vs  TestB4
	    // 부모에서 자녀를 담은 적이 있고, 부모앞에 타입 캐스팅이 되어 있기 때문에
	    // ta는 자녀 tb의 heap area를 담고 있음
	    // ta는 리턴값 자녀의 toString 호출가능 TestB4
	    
	    System.out.println(tb.b);//Q11. 출력내용?
	    // int b=20의 20
	    System.out.println(tb.a);//Q12. 출력내용?
	    // int a=10의 10
	}

}


### 다형성
- 많은 형상을 띄는 성질
- 여러타입의 객체 (자식객체)를 하나의 타입(부모)로 관리

### 부모는 자식을 담을 수 있다. (업캐스팅)
----------------------------------------
Animal [name, age / 먹기, 자기, 배변]
 ↑
Cat  [card / 꾸꾹]

----------------------------------------
> 부모     = 자녀
Animal ani = new Cat();

2-1) Animal ani {name, age / 먹기, 자기, 배변}
2-2) Cat() -> Animal() -> Object()
{card/ 꾹꾹} + {name, age / 먹기, 자기, 배변}


### 자식은 부모를 담을 수 있다. (다운캐스팅)
> 자식  =  부모
Cat cat = new Animal()

3-1) Cat cat;
    {card/ 꾹꾹} + {name, age / 먹기, 자기, 배변}

3-2) new Animal()
                    {name, age / 먹기, 자기, 배변}


3-3) 만족 못 시키는 범위 생김
    {card/ 꾹꾹}

3-4) 해결방안
    부모 타입에서 자식 생성자를 호출한 적이 있으면 사용가능
    Animal ani = new Cat(); 3000번지 {card/꾹꾹} + {name, age, 먹기, 자기, 배변}
            자식생성자를 호출해서 자식의 범위를 쓸 수 있게 만들었으므로 
    Cat cat = (Cat)ani
            부모객체에서 자식타입으로 [타입캐스팅]이 필요함
            cat(3000 번지) = 3000번지 {card/꾹꾹} + {name, age, 먹기, 자기, 배변}

# Abstract
1. 추상화
	- 실제화된 객체들 간에 공통되는 특성을 추출
	- 미완성적인 개념( new를 사용하지 못함 )
	- 공통된 필드와 메서드의 이름을 통일할 목적

2. 추상클래스
class Animal{
	String name; 			// 인스턴스 변수 - this - 각각
	abstract void sound();	// abstract method() - {} 구현부가 없음
}

class Cat extends Animal{ @Override void sound(){야옹} }
class Dog extends Animal{ @Override void sound(){멍멍} }


# interface
1. interface
	- 개발코드 변경없이 객체를 교체하여 사용 할 수 있도록 하는 역할

2. abstract (Is A: 고양이는 동물이다. ) vs interface(can do this)
	- 추상화 정도가 interfacr 쪽이 더 높다.
	1) abstract - 인스턴스변수, 일반메서드, 추상메서드(abstact) 가질 수 있음
	2) interface - 상수 (public static final) + 추상메서드(public abstract)만 가짐.

3) 프로젝트 진행시 interface 사용
	다른 구성원들이 각각의 부분을 완성할 때 까지 기다리지 않고, 
	규약하여 정해진 부분만 본인이 작성.

4) interfact 형식
----------------------------------------------------
interface 인터페이스명 {
	상수;		// public static final
	추상메서드;	 // public abstract {} x - this x
}
----------------------------------------------------

class interSon implements 인터페이스명{}
class interSon2 extends 클래스명 implements 인터페이스1, 인터페이스2{}

# java Abstract 응용문제
# jQuery 선택자